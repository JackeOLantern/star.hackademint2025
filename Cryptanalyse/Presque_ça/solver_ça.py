#!/usr/bin/env python3
from Crypto.Util.number import long_to_bytes

# Données publiques extraites du challenge
N = 177525858978158236964351599640917801414725584912574214601605859362452371576024890042042992697635020680274025347540881914232449944299255293856086203063382527179350592165237483768142615415581520379633997730013970238457527950780852467565508882854136301981320036515393640534328007992627930776727789566639620066803
e = 65537
c = 108260622256457772967783136510011357489954161424060720931542882116755847952610484097893076283088571605243580797900858079451751302172304118890988304923226485473547438250196926994890162681714439377208728562140105159338756266538563702499360776039707885689013818151439367011180609240044436452146901111704401949110

def main():
    # 1) N est premier -> phi(N) = N - 1
    phi = N - 1

    # 2) Calcul de la "clé privée" d = e^{-1} mod phi
    #   Disponibilité de python 3.13 > 3.8 pour pow()
    d = pow(e, -1, phi)

    # 3) Déchiffrement RSA : m = c^d mod N
    m = pow(c, d, N)

    # 4) Conversion en bytes puis en texte
    flag_bytes = long_to_bytes(m)
    try:
        flag = flag_bytes.decode()
    except UnicodeDecodeError:
        flag = repr(flag_bytes)

    print("m =", m)
    print("flag =", flag)

if __name__ == "__main__":
    main()
